#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable

// -----------------------------------------------------------------------------

#include "../interop.h"
#include <material/interop.h>

// -----------------------------------------------------------------------------

hitAttributeEXT vec2 attribs;

layout(location = 0) rayPayloadInEXT HitPayload_t payload;

layout(scalar, set = kDescriptorSet_Internal, binding = kDescriptorSetBinding_MaterialSBO)
buffer RayTracingMaterialSBO_ {
  RayTracingMaterial materials[];
};

layout(set = kDescriptorSet_Scene, binding = kDescriptorSet_Scene_Textures)
uniform sampler2D[] uTextureChannels;

#define TEXTURE_ATLAS(i)  uTextureChannels[nonuniformEXT(i)]

layout(push_constant, scalar) uniform PushConstant_ {
  PushConstant pushConstant;
};

// -----------------------------------------------------------------------------

layout(buffer_reference, scalar) buffer Vertices {
  Vertex v[];
};

layout(buffer_reference, scalar) buffer Indices {
  uint u32[];
};

// -----------------------------------------------------------------------------

struct ObjBuffers_t {
  uint64_t vertexAddr;
  uint64_t indexAddr;
};

layout(set = kDescriptorSet_RayTracing, binding = kDescriptorSet_RayTracing_InstanceSBO, scalar)
buffer _scene_desc {
  ObjBuffers_t addr[];
} ObjBuffers;

// -----------------------------------------------------------------------------

void main() {
  const uint object_id   = uint(gl_InstanceID); //
  const uint material_id = gl_InstanceCustomIndexEXT;

  // ----------------------------------------

  // GEOMETRY.

  ObjBuffers_t obj = ObjBuffers.addr[nonuniformEXT(object_id)];
  Vertices vertices = Vertices(obj.vertexAddr);
  Indices indices   = Indices(obj.indexAddr);

  uint base_index = gl_PrimitiveID * 3;

  uint i0 = indices.u32[base_index + 0];
  uint i1 = indices.u32[base_index + 1];
  uint i2 = indices.u32[base_index + 2];

  Vertex v0 = vertices.v[i0];
  Vertex v1 = vertices.v[i1];
  Vertex v2 = vertices.v[i2];

  // Barycentric coordinates of the triangle
  const vec3 barycentrics = vec3(1.0f - attribs.x - attribs.y, attribs.x, attribs.y);

  // Hit Normal
  vec3 N = v0.normal.xyz * barycentrics.x
         + v1.normal.xyz * barycentrics.y
         + v2.normal.xyz * barycentrics.z;
  N = normalize(vec3(N.xyz * gl_WorldToObjectEXT));

  // Hit Position
  vec3 P = v0.position.xyz * barycentrics.x
         + v1.position.xyz * barycentrics.y
         + v2.position.xyz * barycentrics.z;
  P = vec3(gl_ObjectToWorldEXT * vec4(P, 1.0));

  vec2 uv = v0.texcoord * barycentrics.x
          + v1.texcoord * barycentrics.y
          + v2.texcoord * barycentrics.z;


  // ----------------------------------------

  // MATERIAL.

  const uint kInvalidIndexU24 = 0x00FFFFFF;
  float opacity = 1.0f;

  if (material_id != kInvalidIndexU24)
  {
    RayTracingMaterial mat = materials[nonuniformEXT(material_id)];

    vec4 color = texture(TEXTURE_ATLAS(mat.diffuse_texture_id), uv)
               * mat.diffuse_factor
               ;
    opacity = (color.a > mat.alpha_cutoff) ? 1.0f : 0.0f;
  }

  if (opacity < 0.99f) {
    ignoreIntersectionEXT;
  }

}

// -----------------------------------------------------------------------------
