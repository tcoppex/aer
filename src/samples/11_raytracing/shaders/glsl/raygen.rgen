#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_debug_printf : enable

// ----------------------------------------------------------------------------

#include "../interop.h"

#include <material/interop.h>
#include <shared/random.glsl>

// ----------------------------------------------------------------------------

layout(
  rgba16f,
  set = kDescriptorSet_Internal,
  binding = kDescriptorSetBinding_ImageOutput
) uniform image2D uAccumImage;

layout(scalar,
  set = kDescriptorSet_Frame,
  binding = kDescriptorSet_Frame_FrameUBO
) uniform FrameUBO_ {
  FrameData uFrame;
};

layout(
  set = kDescriptorSet_RayTracing,
  binding = kDescriptorSet_RayTracing_TLAS
) uniform accelerationStructureEXT topLevelAS;

layout(push_constant, scalar) uniform PushConstant_ {
  PushConstant pushConstant;
};

// ----------------------------------------------------------------------------

layout(location = 0) rayPayloadEXT HitPayload_t payload;

void rngSeed(uint frame) {
  uvec2 pixel = gl_LaunchIDEXT.xy;
  uvec3 params = uvec3(pixel, frame);
  payload.rngState = xxhash32(params);
}
vec3 tonemapFilmic(vec3 x) {
  vec3 X = max(vec3(0.0), x - 0.004);
  vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);
  return pow(result, vec3(2.2));
}
// ----------------------------------------------------------------------------

void main() {
  // Normalized device coordinates in [-1, 1]
  ivec2 pixel       = ivec2(gl_LaunchIDEXT.xy);
  vec2 pixelCenter  = vec2(pixel) + vec2(0.5);
  vec2 uv           = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2 ndc          = uv * 2.0 - 1.0;

  // (flip Y to be consistent with the rasterizer viewport flip..)
  ndc.y = -ndc.y;

  vec4 target = uFrame.invProjectionMatrix * vec4(ndc, 1, 1);
  vec4 origin = uFrame.invViewMatrix * vec4(0, 0, 0, 1);
  vec4 direction = uFrame.invViewMatrix * normalize(vec4(target.xyz, 0));
  float tmin = 1e-3;
  float tmax = 1e32;

  payload.origin = origin.xyz;
  payload.direction = direction.xyz;
  payload.radiance = vec3(0.0);
  payload.throughput = vec3(1.0);
  payload.done = 0;
  payload.depth = 0;
  rngSeed(pushConstant.accumulation_frame_count);

  for (int depth = 0; depth < 64; ++depth) {
    traceRayEXT(
      topLevelAS,
      gl_RayFlagsNoneEXT, //gl_RayFlagsOpaqueEXT,
      0xff,
      0, // sbt record offset
      0, // sbt record stride
      0, // miss shader index in miss group
      payload.origin,
      tmin,
      payload.direction,
      tmax,
      0
    );

    if ((payload.done == 1)
     || (dot(payload.throughput, payload.throughput) < 0.001)
    ) {
      break;
    }
  }

#if 1
  vec3 prevSample = imageLoad(uAccumImage, pixel).rgb;
  // To avoid having to clear the initial buffer.
  prevSample = max(vec3(0.0f), prevSample); //

  // if (pushConstant.accumulation_frame_count < 2) {
  //   prevSample = vec3(0.05);
  // }

  vec3 newSample = payload.radiance.rgb;
  // newSample = clamp(newSample, 00.0f, 100.0f);

  float frameCount = float(pushConstant.accumulation_frame_count + 1);
  vec3 color = mix(prevSample, newSample, 1.0 / frameCount);
#else

  uint frameID = pushConstant.accumulation_frame_count;
  vec3 color = vec3(0.5);
  vec3 newSample = payload.radiance.rgb;

  if(frameID == 0) {
    color = pow(newSample, vec3(1.0));
  } else {
    vec3 previousAverage = max(vec4(0), imageLoad(uAccumImage, pixel)).rgb;
    previousAverage = pow(previousAverage, vec3(1.0/2.2));
    vec3 newAverage = (previousAverage.rgb * float(frameID) + newSample) / float(frameID + 1);
    color = newAverage;
  }

#endif

  imageStore(uAccumImage, pixel, vec4(color, 1.0));
}

// ----------------------------------------------------------------------------
