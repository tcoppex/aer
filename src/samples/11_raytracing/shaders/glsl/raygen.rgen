#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

// ----------------------------------------------------------------------------

#include <material/interop.h>
#include "../interop.h" //

// ----------------------------------------------------------------------------

layout(set = kDescriptorSet_Internal, binding = kDescriptorSetBinding_ImageOutput, rgba8)
uniform image2D imageOutput;

layout(set = kDescriptorSet_Frame, binding = kDescriptorSet_Frame_FrameUBO, scalar)
uniform FrameUBO_ {
  FrameData uFrame;
};

layout(set = kDescriptorSet_RayTracing, binding = kDescriptorSet_RayTracing_TLAS)
uniform accelerationStructureEXT topLevelAS;

// ----------------------------------------------------------------------------

struct HitPayload_t {
  vec3 origin;
  vec3 radiance;
  vec3 direction;
  int done;
};

layout(location = 0) rayPayloadEXT HitPayload_t payload;

void main() {
  // Normalized device coordinates in [-1, 1]
  vec2 pixelCenter  = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  vec2 uv           = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2 ndc          = uv * 2.0 - 1.0;

  // (flip Y to be consistent with the rasterizer flip..)
  ndc.y = -ndc.y;

  // We use the same UBO as for the rasterization, but with invert
  // view and proj matrices (names don't changes).
  const mat4 viewInverse = uFrame.viewMatrix;
  const mat4 projInverse = uFrame.projectionMatrix;

  vec4 origin = viewInverse * vec4(0, 0, 0, 1);
  vec4 target = projInverse * vec4(ndc, 1, 1);
  vec4 direction = viewInverse * normalize(vec4(target.xyz, 0));
  float tmin = 1e-3;
  float tmax = 1e32;

  payload.origin = origin.xyz;
  payload.direction = direction.xyz;
  payload.radiance = vec3(0);
  payload.done = 0;

  vec3 hitValue = vec3(0);

  for (int depth=0; depth<64; ++depth) {
    traceRayEXT(
      topLevelAS,
      gl_RayFlagsOpaqueEXT,
      0xff,
      0, // sbt record offset
      0, // sbt record stride
      0, // miss shader index in miss group
      payload.origin,
      tmin,
      payload.direction,
      tmax,
      0
    );
    hitValue += payload.radiance;

    if (payload.done == 1) {
      break;
    }
  }

  vec4 finalColor = vec4(hitValue, 1.0);

  imageStore(imageOutput, ivec2(gl_LaunchIDEXT.xy), finalColor);
}

// ----------------------------------------------------------------------------
