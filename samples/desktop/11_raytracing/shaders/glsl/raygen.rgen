#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

// [hacky] As extension GL_EXT_multiview is not supported on raygen we must
//         override a builtin variable to access the correct uniform buffer
//         camera via the macro GetFrameCamera.
#define gl_ViewIndex 0u

#include <material/interop.h>
#include <shared/random.glsl>

#include "../interop.h"

// ----------------------------------------------------------------------------

layout(
  rgba16f,
  set = kDescriptorSet_Internal,
  binding = kDescriptorSetBinding_ImageOutput
) uniform image2D uAccumImage;

layout(scalar,
  set = kDescriptorSet_Frame,
  binding = kDescriptorSet_Frame_FrameUBO
) uniform FrameUBO_ {
  FrameData uFrame;
};

layout(
  set = kDescriptorSet_RayTracing,
  binding = kDescriptorSet_RayTracing_TLAS
) uniform accelerationStructureEXT topLevelAS;

layout(push_constant, scalar) uniform PushConstant_ {
  PushConstant pushConstant;
};

// ----------------------------------------------------------------------------

layout(location = 0) rayPayloadEXT HitPayload_t payload;

// -----------------------------------------------------------------------------

void russianRoulette() {
  if (payload.depth > 4) {
    float p = max(payload.throughput.r,
              max(payload.throughput.g, payload.throughput.b));
    p = clamp(p, 0.05, 0.95);
    if (randf(payload.rngState) > p) {
      payload.done = 1;
      return;
    } else {
      payload.throughput /= p;
    }
  }
}

// ----------------------------------------------------------------------------

void main() {
  ivec2 pixel       = ivec2(gl_LaunchIDEXT.xy);
  vec2 pixelCenter  = vec2(pixel) + vec2(0.5);
  vec2 sampleSize   = 1.0f / vec2(gl_LaunchSizeEXT.xy);
  vec2 uv           = pixelCenter * sampleSize;

  // Normalized device coordinates in [-1, 1]
  vec2 ndc = uv * 2.0 - 1.0;
  // (flip Y to be consistent with the rasterizer viewport flip..)
  ndc.y = -ndc.y;

  // Initialize RNG for the pixel.
  uvec3 seed_params = uvec3(gl_LaunchIDEXT.xy, pushConstant.accumulation_frame_count);
  payload.rngState = xxhash32(seed_params);

  const CameraTransform camera = GetFrameCamera(uFrame);
  const vec4 origin = camera.invViewMatrix * vec4(0, 0, 0, 1);

  const int numSamples = pushConstant.num_samples;
  const int maxDepth = 16; //

  vec3 color = vec3(0.0);
  for (int s = 0; s < numSamples; s++)
  {
    vec2 jitter = pushConstant.jitter_factor * (rand2f(payload.rngState) - 0.5) * sampleSize;
    vec4 target = camera.invProjectionMatrix * vec4(ndc + jitter, 0, 1);
    vec4 direction = camera.invViewMatrix * normalize(vec4(target.xyz, 0));

    float tmin = 1e-3;
    float tmax = 1e32;

    payload.origin = origin.xyz;
    payload.direction = direction.xyz;
    payload.radiance = vec3(0.0);
    payload.throughput = vec3(1.0);
    payload.depth = 0;
    payload.done = 0;

    for (int depth = 0; depth < maxDepth; ++depth) {
      traceRayEXT(
        topLevelAS,
        gl_RayFlagsNoneEXT,
        0xff,
        0, // sbt record offset
        0, // sbt record stride
        0, // miss shader index in miss group
        payload.origin,
        tmin,
        payload.direction,
        tmax,
        0
      );
      russianRoulette();

      if ((payload.done == 1)
       || (dot(payload.throughput, payload.throughput) < 0.001)
      ) {
        break;
      }
    }
    color += payload.radiance;
  }
  color /= numSamples;

  vec3 prevSample = imageLoad(uAccumImage, pixel).rgb;
  // To avoid having to clear the initial buffer.
  prevSample = max(vec3(0.0f), prevSample); //

  vec3 newSample = color; //payload.radiance.rgb;
  newSample = clamp(newSample, 00.0f, 100.0f);

  float frameCount = float(pushConstant.accumulation_frame_count + 1);
  color = mix(prevSample, newSample, 1.0 / frameCount);

  imageStore(uAccumImage, pixel, vec4(color, 1.0));
}

// ----------------------------------------------------------------------------
